const { Asset } = require("parcel-bundler");
const localRequire = require("parcel-bundler/lib/utils/localRequire");

class TypeScriptAsset extends Asset {
  constructor(name, options) {
    super(name, options);
    this.type = "js";
  }

  async generate() {
    // Require typescript, installed locally in the app
    let typescript = await localRequire("esbuild", this.name);
    let transpilerOptions = {
      compilerOptions: {
        module: this.options.scopeHoist ? "exnext" : "commonjs",
        jsx: "preserve",

        // It brings the generated output from TypeScript closer to that generated by Babel
        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html
        esModuleInterop: true
      },
      fileName: this.relativeName
    };

    let tsconfig = await this.getConfig(["tsconfig.json"]);

    // Overwrite default if config is found
    if (tsconfig) {
      transpilerOptions.compilerOptions = Object.assign(
        transpilerOptions.compilerOptions,
        tsconfig.compilerOptions
      );
    }

    transpilerOptions.compilerOptions.noEmit = false;
    transpilerOptions.compilerOptions.sourceMap = this.options.sourceMaps;

    // Transpile Module using TypeScript and parse result as ast format through babylon
    let transpiled = await typescript.transform(this.contents, {
      tsconfigRaw: {
        transpilerOptions
      },
      sourcefile: this.relativeName,
      loader: "ts"
    });
    let sourceMap = transpiled.map;

    if (sourceMap) {
      sourceMap = JSON.parse(sourceMap);
      sourceMap.sources = [this.relativeName];
      sourceMap.sourcesContent = [this.contents];

      // Remove the source map URL
      let content = transpiled.code;
      transpiled.code = content.substring(
        0,
        content.lastIndexOf("//# sourceMappingURL")
      );
    }

    return [
      {
        type: "js",
        value: transpiled.code,
        sourceMap
      }
    ];
  }
}

module.exports = TypeScriptAsset;
