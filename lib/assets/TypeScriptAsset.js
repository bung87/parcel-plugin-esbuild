const { Asset } = require("parcel-bundler");
const localRequire = require("parcel-bundler/lib/utils/localRequire");
const readBabelrcUp = require("read-babelrc-up");
const e2c = require("electron-to-chromium");
function marjorVersion(v) {
  return v.indexOf(".") === -1 ? v : v.substring(0, v.indexOf("."));
}

class TypeScriptAsset extends Asset {
  constructor(name, options) {
    super(name, options);
    this.type = "js";
  }

  async generate() {
    // Require typescript, installed locally in the app
    let typescript = await localRequire("esbuild", this.name);
    let transpilerOptions = {
      compilerOptions: {
        module: this.options.scopeHoist ? "exnext" : "commonjs",
        jsx: "preserve",

        // It brings the generated output from TypeScript closer to that generated by Babel
        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html
        esModuleInterop: true
      },
      fileName: this.relativeName
    };

    let tsconfig = await this.getConfig(["tsconfig.json"]);

    // Overwrite default if config is found
    if (tsconfig) {
      const { compilerOptions, ...rest } = tsconfig;
      transpilerOptions.compilerOptions = Object.assign(
        transpilerOptions.compilerOptions,
        compilerOptions
      );
      Object.assign(transpilerOptions, rest);
    }

    transpilerOptions.compilerOptions.noEmit = false;
    transpilerOptions.compilerOptions.sourceMap = this.options.sourceMaps;

    // Transpile Module using TypeScript and parse result as ast format through babylon
    const loader = this.relativeName.substring(
      this.relativeName.lastIndexOf(".") + 1
    );
    let babelrc;
    try {
      babelrc = await readBabelrcUp();
    } catch (_) {}

    let _targets = transpilerOptions.compilerOptions.target;
    if (babelrc) {
      const presetEnv = babelrc.babel.presets.find(
        e => Array.isArray(e) && e[0] === "@babel/preset-env"
      );
      if (presetEnv) {
        const targets = presetEnv[1].targets;
        _targets = Object.entries(targets).map(([k, v], _) => {
          if (k === "electron") {
            return "chrome" + marjorVersion(e2c.electronToChromium(v));
          }

          return k + marjorVersion(v);
        });
      }
    }

    let transpiled = await typescript.transform(this.contents, {
      tsconfigRaw: JSON.stringify(transpilerOptions),
      sourcemap: transpilerOptions.compilerOptions.sourceMap
        ? "external"
        : false,
      sourcefile: this.relativeName,
      loader,
      target: _targets
    });

    let sourceMap = transpiled.map;

    if (sourceMap) {
      sourceMap = JSON.parse(sourceMap);
      sourceMap.sources = [this.relativeName];
      sourceMap.sourcesContent = [this.contents];
    }

    return [
      {
        type: "js",
        value: transpiled.code,
        sourceMap
      }
    ];
  }
}

module.exports = TypeScriptAsset;
